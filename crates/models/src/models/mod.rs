use actix_web::http::StatusCode;
use adaptarr_error::ApiError;
use diesel::result::Error as DbError;
use failure::Fail;
use std::{borrow::Cow, convert::Infallible, fmt, marker::PhantomData};

use crate::db::Connection;

mod book;
mod bookpart;
mod document;
mod draft;
mod event;
mod file;
mod invite;
mod module;
mod password;
mod resource;
mod role;
mod user;
mod xref_target;

pub mod editing;

pub use self::{
    book::Book,
    bookpart::{BookPart, CreatePartError, NewTree, ReparentPartError, Tree},
    document::Document,
    draft::{AdvanceResult, Draft},
    event::Event,
    file::{CNXML_MIME, CreateFileError, File},
    invite::Invite,
    module::{Module, ReplaceModuleError},
    password::PasswordResetToken,
    resource::{Resource, ResourceFileError},
    role::Role,
    user::{
        ChangePasswordError,
        CreateUserError,
        Fields as UserFields,
        User,
        UserAuthenticateError,
    },
    xref_target::XrefTarget,
};

/// Trait describing common functionality for all models.
pub trait Model: Sized {
    /// Category to use for errors generated by this model.
    const ERROR_CATEGORY: &'static str;

    /// Type used to identify instances of this model.
    ///
    /// Some models can't be directly indexed. In those cases the `!` “never”
    /// type (or [`std::convert::Infallible`]) should be used as the ID type.
    type Id: Clone + Copy + Eq;

    /// Database representation of this model.
    type Database;

    /// A public subset of this model's data.
    type Public;

    /// Parameters to [`Self::get_public_full`].
    type PublicParams;

    /// Find by ID an instance of this model in the database.
    fn by_id(db: &Connection, id: Self::Id) -> FindModelResult<Self>;

    fn from_db(data: Self::Database) -> Self;

    /// Get underlying database models.
    fn into_db(self) -> Self::Database;

    /// Get ID of this instance.
    fn id(&self) -> Self::Id;

    /// Get the public portion of this draft's data, excluding data which would
    /// have to be fetched from the database.
    fn get_public(&self) -> Self::Public;

    /// Get the public portion of this book's data.
    fn get_public_full(&self, _: &Connection, _: &Self::PublicParams)
    -> Result<Self::Public, DbError> {
        Ok(self.get_public())
    }
}

pub type FindModelResult<M> = Result<M, FindModelError<M>>;

#[derive(Fail)]
pub enum FindModelError<M: Model + 'static> {
    /// No instance of model matching specified ID could be found.
    #[fail(display = "not found")]
    NotFound(PhantomData<*const M>),
    /// Instance could not be retrieved due to a database error.
    #[fail(display = "database error: {}", _1)]
    Database(PhantomData<*const M>, #[cause] diesel::result::Error),
}

impl<M: Model + 'static> FindModelError<M> {
    /// Convenience method for constructing [`FindModelError::NotFound`].
    pub fn not_found() -> Self {
        Self::NotFound(PhantomData)
    }
}

unsafe impl<M: Model> Sync for FindModelError<M> {}
unsafe impl<M: Model> Send for FindModelError<M> {}

impl<M: Model> fmt::Debug for FindModelError<M> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
        let mut fmt = fmt.debug_tuple(match self {
            Self::NotFound(_) => "NotFound",
            Self::Database(_, _) => "Database",
        });

        if let Self::Database(_, ref err) = self {
            fmt.field(err);
        }

        fmt.finish()
    }
}

impl<M: Model + 'static> ApiError for FindModelError<M> {
    fn status(&self) -> StatusCode {
        match self {
            Self::NotFound(_) => StatusCode::NOT_FOUND,
            Self::Database(_, _) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }

    fn code(&self) -> Option<Cow<str>> {
        match self {
            Self::NotFound(_) => Some(Cow::from(format!("{}:not-found", <M as Model>::ERROR_CATEGORY))),
            Self::Database(_, _) => None,
        }
    }
}

/// Trait for types which can represent absence of a model due to either it not
/// existing, or due to an error in retrieving it. This trait enhances those
/// types with an ability to assert that the first case cannot occur.
///
/// As an example, when retrieving a model which is known to exist (for example
/// because database constraints guarantee it), instead of having to support
/// [`FindModelError`], once can use [`Self::assert_exists`] to convert a
/// `Result<Model, FindModelError<Model>>` into a `Result<Model,
/// diesel::result::Error>`.
pub trait AssertExists {
    /// Result of asserting existence.
    type Output;

    /// Assert that the underlying model exists.
    ///
    /// This function must panic if the model doesn't exist.
    fn assert_exists(self) -> Self::Output;
}

impl<M: Model> AssertExists for FindModelError<M> {
    type Output = diesel::result::Error;

    fn assert_exists(self) -> diesel::result::Error {
        match self {
            FindModelError::NotFound(_) => panic!("database inconsistency"),
            FindModelError::Database(_, err) => err,
        }
    }
}

impl<T, E: AssertExists> AssertExists for Result<T, E> {
    type Output = Result<T, <E as AssertExists>::Output>;

    fn assert_exists(self) -> Self::Output {
        self.map_err(AssertExists::assert_exists)
    }
}

impl<M: Model> From<DbError> for FindModelError<M> {
    fn from(e: DbError) -> Self {
        match e {
            DbError::NotFound => FindModelError::NotFound(PhantomData),
            e => FindModelError::Database(PhantomData, e),
        }
    }
}

impl<T> Model for Vec<T>
where
    T: Model,
{
    const ERROR_CATEGORY: &'static str = <T as Model>::ERROR_CATEGORY;

    type Id = Infallible;
    type Database = Vec<T::Database>;
    type Public = Vec<T::Public>;
    type PublicParams = T::PublicParams;

    fn by_id(_: &Connection, _: Self::Id) -> FindModelResult<Self> {
        unreachable!()
    }

    fn from_db(data: Self::Database) -> Self {
        data.into_iter().map(T::from_db).collect()
    }

    fn into_db(self) -> Self::Database {
        self.into_iter().map(T::into_db).collect()
    }

    fn id(&self) -> Self::Id {
        unreachable!()
    }

    fn get_public(&self) -> Self::Public {
        self.iter().map(T::get_public).collect()
    }

    fn get_public_full(&self, db: &Connection, params: &Self::PublicParams)
    -> Result<Self::Public, DbError> {
        self.iter().map(|t| t.get_public_full(db, params)).collect()
    }
}
